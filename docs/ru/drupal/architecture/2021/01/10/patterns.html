<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Merriweather:300|Raleway:400,700" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">

<link rel="canonical" href="https://www.enik.pro/ru/drupal/architecture/2021/01/10/patterns.html" />
<meta property="og:url" content="https://www.enik.pro/ru/drupal/architecture/2021/01/10/patterns.html" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-2607843-20"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-2607843-20');
</script>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Шаблоны проектирования в Drupal 9</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Шаблоны проектирования в Drupal 9" />
<meta name="author" content="Evgenii Nikitin" />
<meta property="og:locale" content="ru" />
<meta name="description" content="Drupal разработчики редко имеют дело с паттернами проектирования объектов, т.к. в основном им приходится работать в уже сформированной среде. Мы используем шаблоны каждый день, но даже не задумываемся над этим. Имея представление о паттернах вам будет легче общаться с коллегами - достаточно сказать название паттерна и все понимают о чем идет речь. Вместо изобретения очередного велосипеда вы можете использовать уже отработанные эффективные решения. Паттерны проектирования одни и те же в разных языках программирования, отличается только реализация. Так что зная шаблоны вы всегда сможете найти им применение в своей карьере. Кстати, вопрос о паттернах проектирования один из самых частых при собеседованиях." />
<meta property="og:description" content="Drupal разработчики редко имеют дело с паттернами проектирования объектов, т.к. в основном им приходится работать в уже сформированной среде. Мы используем шаблоны каждый день, но даже не задумываемся над этим. Имея представление о паттернах вам будет легче общаться с коллегами - достаточно сказать название паттерна и все понимают о чем идет речь. Вместо изобретения очередного велосипеда вы можете использовать уже отработанные эффективные решения. Паттерны проектирования одни и те же в разных языках программирования, отличается только реализация. Так что зная шаблоны вы всегда сможете найти им применение в своей карьере. Кстати, вопрос о паттернах проектирования один из самых частых при собеседованиях." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-01-10T07:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Шаблоны проектирования в Drupal 9" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Evgenii Nikitin"},"dateModified":"2021-01-10T07:00:00+01:00","datePublished":"2021-01-10T07:00:00+01:00","description":"Drupal разработчики редко имеют дело с паттернами проектирования объектов, т.к. в основном им приходится работать в уже сформированной среде. Мы используем шаблоны каждый день, но даже не задумываемся над этим. Имея представление о паттернах вам будет легче общаться с коллегами - достаточно сказать название паттерна и все понимают о чем идет речь. Вместо изобретения очередного велосипеда вы можете использовать уже отработанные эффективные решения. Паттерны проектирования одни и те же в разных языках программирования, отличается только реализация. Так что зная шаблоны вы всегда сможете найти им применение в своей карьере. Кстати, вопрос о паттернах проектирования один из самых частых при собеседованиях.","headline":"Шаблоны проектирования в Drupal 9","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.enik.pro/ru/drupal/architecture/2021/01/10/patterns.html"},"url":"https://www.enik.pro/ru/drupal/architecture/2021/01/10/patterns.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
	<main class="container">
		<section class="about">
			<a href="/ru/" title="Главная страница"><img src="/assets/portfolio_white.png" alt="Евгений Никитин"/></a>
			<a href="/ru/about" title="О Евгении Никитине" class="name">Евгений Никитин</a>
			<p class="tagline"></p>
			<ul class="social">
				<a href="https://www.linkedin.com/in/nikitinevgeny" target="_blank"><li><i class="icon-linkedin-squared"></i></li></a>
				<a href="https://www.drupal.org/u/sinn" target="_blank"><li><i class="icon-drupal"></i></li></a>
			</ul>

			<p>
			  <a href="/ru/drupal/architecture/2021/01/10/patterns.html" title="Русский">Русский</a>
			  <a href="/drupal/architecture/2021/01/10/patterns.html" title="English">English</a>
			</p>
		</section>
		<section class="content">
			<div class="post-container">
	<h1>Шаблоны проектирования в Drupal 9</h1>

	<div class="post-meta">
		<ul class="post-categories"><li>Drupal</li><li>architecture</li></ul>
		<div class="post-date"><i class="icon-calendar"></i>Jan 10, 2021</div>
	</div>
	<div class="post">
		<p>Drupal разработчики редко имеют дело с паттернами проектирования объектов, т.к. в основном им приходится работать в уже сформированной среде. Мы используем шаблоны каждый день, но даже не задумываемся над этим. Имея представление о паттернах вам будет легче общаться с коллегами - достаточно сказать название паттерна и все понимают о чем идет речь. Вместо изобретения очередного велосипеда вы можете использовать уже отработанные эффективные решения. Паттерны проектирования одни и те же в разных языках программирования, отличается только реализация. Так что зная шаблоны вы всегда сможете найти им применение в своей карьере. Кстати, вопрос о паттернах проектирования один из самых частых при собеседованиях.</p>

<h2 id="порождающие-паттерны">Порождающие паттерны</h2>

<h3 id="одиночка-singleton">Одиночка (Singleton)</h3>

<p><strong>“Одиночка”</strong> - это, наверное, самый известный архитектурный паттерн. Его назначение - это создавать единственный  экземпляр класса и предоставлять единую точку доступа к объекту.</p>

<p>В Drupal с помощью шаблона “Одиночка” реализован доступ к настройками сайта. На схеме внизу изображено как это работает:</p>

<p><img src="/assets/content/2021-01-10-patterns/singleton.png" alt="Шаблон Одиночка в Drupal" /></p>

<p>Во время начальной загрузки ядра Drupal инициализирует настройки используя <code class="language-plaintext highlighter-rouge">Settings::initialize()</code>. После этого экземпляр класса помещается в защищенную переменную <code class="language-plaintext highlighter-rouge">self::$instance</code>, откуда он берется в дальнейшем. Настройки сайта являются общим ресурсом, поэтому шаблон “Одиночка” позволяет Drupal обращаться к настройкам только один раз при инициализации.</p>

<h3 id="фабричный-метод-factory-method">Фабричный метод (Factory method)</h3>

<p><strong>“Фабричный метод”</strong> определяет общий интерфейс для создания объектов. Тип объекта, что будет создан, может быть изменен в зависимости от настроек.</p>

<p>В Drupal “Фабричный метод” используется для получения объекта для работы с кешем. Различные типы кеша требуют собственную реализацию, поэтому у нас есть классы реализующие интерфейс <code class="language-plaintext highlighter-rouge">CacheBackendInterface</code> такие как <code class="language-plaintext highlighter-rouge">DatabaseBackend</code>, <code class="language-plaintext highlighter-rouge">PhpBackend</code>, <code class="language-plaintext highlighter-rouge">MemoryBackend</code> и т.д. для работы с разными видами кеша. К тому же для разных подсистем кеш у нас может быть разный. Поэтому был определен интерфейс <code class="language-plaintext highlighter-rouge">CacheFactoryInterface</code> и его реализации <code class="language-plaintext highlighter-rouge">DatabaseBackendFactory</code>, <code class="language-plaintext highlighter-rouge">PhpBackendFactory</code>, <code class="language-plaintext highlighter-rouge">MemoryBackendFactory</code> и т.д., которые создают объекты для работы с кешем определенного типа. Для каждого класса, реализующий интерфейс, <code class="language-plaintext highlighter-rouge">CacheBackendInterface</code> у нас есть своя фабрика реализующая <code class="language-plaintext highlighter-rouge">CacheFactoryInterface</code>.</p>

<p>Какую конкретно использовать фабрику решается в классе <code class="language-plaintext highlighter-rouge">\Drupal\Core\Cache\CacheFactory</code> - в зависимости от настроек системы используется та или иная фабрика. Поэтому, например, чтобы получить объект для работы с кешем рендеринга вам нужно просто выполнить <code class="language-plaintext highlighter-rouge">\Drupal::service(‘cache_factory’)-&gt;get(‘render’)</code>. Вам не нужно знать какой конкретно тип кеша используется в системе для рендеринга шаблонов. В <code class="language-plaintext highlighter-rouge">settings.php</code> вы можете выставить</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">settings</span><span class="p">[</span><span class="s1">'cache'</span><span class="p">][</span><span class="s1">'bins'</span><span class="p">][</span><span class="s1">'render'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'cache.backend.database'</span><span class="p">;</span>
</code></pre></div></div>
<p>или</p>
<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">settings</span><span class="p">[</span><span class="s1">'cache'</span><span class="p">][</span><span class="s1">'bins'</span><span class="p">][</span><span class="s1">'render'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'cache.backend.memcache'</span><span class="p">;</span>
</code></pre></div></div>
<p>и фабрика вернет вам объект класса <code class="language-plaintext highlighter-rouge">DatabaseBackend</code> либо <code class="language-plaintext highlighter-rouge">MemcacheBackend</code> в зависимости от настроек.</p>

<p>Также к преимуществам фабричного метода относится то, что он позволяет возвращать уже созданные объекты, а не создавать их каждый раз заново, что сэкономит вам ресурсы (пример <code class="language-plaintext highlighter-rouge">\Drupal\Core\Cache\MemoryBackendFactory</code>).</p>

<p><img src="/assets/content/2021-01-10-patterns/factory.png" alt="Шаблон Фабричный метод в Drupal" /></p>

<h3 id="внедрение-зависимостей-dependency-injection">Внедрение зависимостей (Dependency injection)</h3>

<p><strong>“Внедрение зависимостей”</strong> - явная передача служб в объект используя конструктор или сеттеры. 
В Drupal мы определяем объекты-сервисы, ответственные за определенные функции. Когда нам нужны эти сервисы в наших классах мы:</p>
<ul>
  <li>описываем зависимости как аргументы при определении сервисов в <code class="language-plaintext highlighter-rouge">*.services.yml</code>. Эти зависимости будут переданы в <code class="language-plaintext highlighter-rouge">__construct()</code> метод.</li>
  <li>используем интерфейс <code class="language-plaintext highlighter-rouge">ContainerFactoryPluginInterface</code> для плагинов.</li>
  <li>используем интерфейс <code class="language-plaintext highlighter-rouge">ContainerInjectionInterface</code> для остальных объектов (но не везде, например Entity не поддерживают внедрение зависимостей).</li>
</ul>

<p><img src="/assets/content/2021-01-10-patterns/dependency_injection.png" alt="Пример работы ввнедрения зависимостей в Drupal" /></p>

<p>На схеме описано как сервисы “config_factory”, “alias_manager”, “path_validator”, “request_context” добавляются в форму <code class="language-plaintext highlighter-rouge">SiteInformationForm</code>. При создании формы мы их получаем в конструкторе и сохраняем во внутренних переменных класса - зависимости внедрены.</p>

<p>Данный шаблон позволяет с легкостью распределять ответственность между классами. К тому же мы не зависим от конкретной реализации зависимости - нам нужно только знать какой интерфейс она имплементирует. Поэтому, в дальнейшем мы можем передать в объект другую реализацию зависимости без изменения самого объекта.</p>

<h2 id="поведенческие-паттерны">Поведенческие паттерны</h2>

<h3 id="посредник-intermediary-controller-mediator">Посредник (Intermediary, Controller, Mediator)</h3>

<p>Шаблон <strong>“Посредник”</strong> используется для реализации взаимодействия между компонентами приложения.</p>

<p>Вы будете удивлены, но паттерн “Посредник” является основой для главной отличительной особенности Drupal - системы хуков. У нас есть основной элемент - посредник, который предоставляет единый интерфейс через который общаются разные части системы. Компоненты-получатели не знают кто отправил запрос, а компоненты-отправители не знают кто обработает запрос.</p>

<p>На схеме внизу представлено как работают хуки. В нашем примере, когда компонент-отправитель <code class="language-plaintext highlighter-rouge">EntityStorageBase</code> хочет уведомить о каком-либо событии (это может быть: presave, create, insert, update, delete, revision_delete, predelete) произошедшим с Entity, он вызывает посредник <code class="language-plaintext highlighter-rouge">ModuleHandler</code> и передает ему название события/хука и параметры. <code class="language-plaintext highlighter-rouge">ModuleHandler</code> содержит в себе ссылки на все хуки в системе в параметре <code class="language-plaintext highlighter-rouge">implementations</code>. Затем он вызывает соответствующие методы-хуки c передаными параметрами.</p>

<p><img src="/assets/content/2021-01-10-patterns/mediator_hooks.png" alt="Схема работы хук в шаблоне Посредник" /></p>

<p>Также паттерн “Посредник” используется в системе событий, которая в Drupal построена на основе <a href="https://symfony.com/components/EventDispatcher">Symfony EventDispatcher</a>. Здесь посредником является <code class="language-plaintext highlighter-rouge">ContainerAwareEventDispatcher</code>. Компоненты-отправители (в нашем примере это <code class="language-plaintext highlighter-rouge">\Drupal\Core\Config</code>) уведомляют посредник о наступлении события. В переменной <code class="language-plaintext highlighter-rouge">listeners</code> в посреднике находятся ссылки на все компоненты-подписчики (реализуют <code class="language-plaintext highlighter-rouge">EventSubscriberInterface</code>). Когда посредник получает уведомление о событии он вызывает подписчики, которые подписаны на вызываемое событие.</p>

<p><img src="/assets/content/2021-01-10-patterns/mediator_events.png" alt="Система событий Drupal в шаблоне Посредник" /></p>

<h3 id="посетитель-visitor">Посетитель (Visitor)</h3>

<p>Шаблон <strong>“Посетитель”</strong> используется для того чтобы отделить операции над объектом от самого объекта. Таким образом, не затрагивая структуру объекта мы можем добавить в программу какие-либо действия с ним.</p>

<p>Шаблон “Посетитель” мы можем найти в Twig в парсинге шаблонов - строится дерево элементов (html тегов) шаблона и затем, при обходе дерева, эти элементы обрабатываются объектами-посетителями.</p>

<p><img src="/assets/content/2021-01-10-patterns/visitor.png" alt="Шаблон Посетитель в Drupal" /></p>

<p>Как вы видите на схеме в Twig используются разные объекты-посетители (<code class="language-plaintext highlighter-rouge">EscaperNodeVisitor</code>, <code class="language-plaintext highlighter-rouge">TwigNodeVisitor</code>, <code class="language-plaintext highlighter-rouge">SelfAnalysisNodeVisitor</code>). Если нам нужно будет обработать элементы как-то еще, то мы можем добавить дополнительный посетитель без изменения класса элемента.</p>

<p>Если разные элементы должны быть обработаны по-разному, то посетитель реализует у себя эти варианты (посмотрите на пример <code class="language-plaintext highlighter-rouge">SelfAnalysisNodeVisitor</code> - для каждого элемента своя реализация алгоритма). Данный шаблон хорошо подходит если нам редко приходится изменять элементы над которыми мы совершаем операции. При изменении элемента может потребоваться внести изменения в реализацию посетителей.</p>

<h2 id="структурные-паттерны">Структурные паттерны</h2>

<h3 id="заместитель-proxy">Заместитель (Proxy)</h3>

<p>Шаблон <strong>“Заместитель”</strong> применяется когда нужно использовать вместо реальных объектов объекты-заместители. Эти объекты позволят выполнять код до или после вызова методов оригинального объекта, или управлять доступом к оригинальному объекту.</p>

<p>В Drupal паттерн “Заместитель” реализован в классе <code class="language-plaintext highlighter-rouge">\Drupal\Core\Session\AccountProxy</code> сервиса “current_user”. <code class="language-plaintext highlighter-rouge">AccountProxy</code> реализует все методы класса <code class="language-plaintext highlighter-rouge">\Drupal\Core\Session\UserSession</code> чьим заместителем он является. Таким образом мы можем работать с объектом класса <code class="language-plaintext highlighter-rouge">AccountProxy</code> также как с объектом класса <code class="language-plaintext highlighter-rouge">UserSession</code>. Данный подход позволяет устанавливать и менять текущего пользователя без повторной инициализации сервиса “current_user”. К тому же, этот сервис используется всеми сервисами как единая точка доступа к сессии текущего пользователя.</p>

<p><img src="/assets/content/2021-01-10-patterns/proxy.png" alt="Шаблон Заместитель в Drupal" /></p>

<p><strong>Ссылки</strong></p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Software_design_pattern">Список шаблонов проектирования на Википедии</a></li>
  <li><a href="https://refactoring.guru/">Шаблоны проектирования с примерами</a></li>
  <li><a href="https://martinfowler.com/articles/injection.html">Внедрение зависимостей от Мартина Фаулера</a></li>
</ul>

	</div>

	<div id="disqus_thread" style="margin-top:25px"></div>
	<script>
		var disqus_config = function () {
    		this.page.url = 'https://www.enik.pro/drupal/architecture/2021/01/10/patterns.html';
    		this.page.identifier = 'https://www.enik.pro/drupal/architecture/2021/01/10/patterns.html';
    	};
		(function() {
			var d = document, s = d.createElement('script');
			s.src = 'https://enik-io.disqus.com/embed.js';
			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
		})();
  	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

		</section>
	</main>
</body>
</html>
